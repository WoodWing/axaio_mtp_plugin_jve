<?php
/**
 * CLI tool (called by build server Zetes) that converts XML files generated by phpStorm 
 * Code Inspection into JUnit XML (to let Jenkins render the report in its UI).
 * 
 * Usage: 
 *    php xml2junit.php <input folder path to scan for xml files> <output file path to write jUnit file>'
 *
 * A folder must be specified from where XML files are read recusively. A file must be specified
 * that is used to write all converted information into. So there are many input files and just
 * one output file.
 *
 * For each read XML input file, a testsuite element is created in the JUnit output file.
 * Each folder that is scanned is indicated in the testsuite->package attribute.
 * For each problem found in the XML file, a testcase is created. 
 *
 * In short, info is mapped as follows:
 * --------------------------------------
 *  JUnit      <=> phpStorm XML
 * --------------------------------------
 *  testsuites <=> folder with XML files
 *  testsuite  <=> problems of XML file
 *  testcase   <=> problem
 * --------------------------------------
 *
 * Following JUnit XSD standard is used by Jenkins and therefore respected by this converter:
 *    https://svn.jenkins-ci.org/trunk/hudson/dtkit/dtkit-format/dtkit-junit-model/src/main/resources/com/thalesgroup/dtkit/junit/model/xsd/junit-4.xsd
 */
class PhpStormXml2JunitXmlConverter
{
	/** @var DOMNode $jRoot Root node of $jDoc. */
	private $jRoot;
	
	/** @var DOMDocument $jDoc Generated JUnit XML. */
	private $jDoc;
	
	/** @var integer $suiteId Iterator to give each testsuite its own id.  */
	private $suiteId;
	
	/** @var integer $totalTestCount Total number of imported tests.  */
	private $totalTestCount; // integer

	/** @var integer $totalFailureCount Total number of imported tests that indicate failure.  */
	private $totalFailureCount;

	/** @var integer $totalErrorCount Total number of imported tests that indicate error.  */
	private $totalErrorCount;
	
	/** @var integer $numberOfErrorsToIgnore Total number of errors we can ignore. */
	private $numberOfErrorsToIgnore;
	
	/** @var integer $errorCountExceedingFolders Total number of errors for each folder that was not configured. */
	private $errorCountExceedingFolders;
	
	/**
	 * Converts a folder with XML file into a JUnit file. See also module header.
	 *
	 * @param string $folderPath
	 * @param string $jUnitFilePath
	 */
	public function convertFilesInFolder( $folderPath, $jUnitFilePath )
	{
		$this->jDoc = new DOMDocument('1.0','UTF-8');
		$this->jRoot = $this->jDoc->createElement( 'testsuites' );
		$this->jDoc->appendChild( $this->jRoot );
		
		$this->suiteId = 1;
		$this->totalTestCount = 0;
		$this->totalFailureCount = array();
		$this->totalErrorCount = array();
		$this->errorCountExceedingFolders = array();
		$this->numberOfErrorsToIgnore = array();
		
		// Read the config file to resolve the max allowed errors per folder.
		$configDoc = new DOMDocument();
		$configDoc->loadXML( file_get_contents( dirname(__FILE__).'/phpstorm2junit.xml' ) );
		$xPath = new DOMXPath( $configDoc );
		$xmlFolders = $xPath->query( '/folders/folder' );
		foreach( $xmlFolders as $xmlFolder ) {
			$name = $xmlFolder->getAttribute( 'path' );
			$maxerr = $xmlFolder->getAttribute( 'maxerr' );
			$this->numberOfErrorsToIgnore[$name] = $maxerr;
		}
		foreach( array_keys($this->numberOfErrorsToIgnore) as $configFolder ) {
			$this->totalFailureCount[$configFolder] = 0;
			$this->totalErrorCount[$configFolder] = 0;
		}
		
		// Parse all XML files found in the given folder and collect errors.
		$this->doConvertFilesInFolder( $folderPath, $jUnitFilePath, '' );
		$this->reportErrorsForMissingFolders();
		
		$this->jRoot->setAttribute( 'name', 'phpStorm Code Inspection' );
		$this->jRoot->setAttribute( 'tests', $this->totalTestCount );
		$this->jRoot->setAttribute( 'failures', array_sum($this->totalFailureCount) );
		$this->jRoot->setAttribute( 'errors', array_sum($this->totalErrorCount) );
		// L> ignoring attributes: disabled, time

		$this->jDoc->formatOutput = true;
		file_put_contents( $jUnitFilePath, $this->jDoc->saveXML() );
	}
			
	/**
	 * Converts a folder with XML file into a JUnit file. See also module header.
	 *
	 * @param string $folderPath
	 * @param string $jUnitFilePath
	 * @param string $package
	 */
	private function doConvertFilesInFolder( $folderPath, $jUnitFilePath, $package )
	{
		// Iterate through all xml files in the given folder.
		$dir = opendir( $folderPath );
		while( false !== ( $fileName = readdir($dir) ) ) {
			if( $fileName && $fileName[0] != '.' ) {
				$filePath = $folderPath . '/' . $fileName;
				if( is_file( $filePath ) ) {
					if( substr( $fileName, -4 ) == '.xml' ) {
						$this->convertFile( $filePath, $package );
					}
				} elseif( is_dir( $filePath ) ) {
					$package = $package ? $package.'/'.$fileName : $fileName;
					$this->doConvertFilesInFolder( $filePath, $jUnitFilePath, $package );
				}
			}
		}
		closedir( $dir );
	}

	/**
	 * Converts a XML file and updates the JUnit DOM. See also module header.
	 *
	 * @param string $filePath
	 * @param string $package
	 */
	private function convertFile( $filePath, $package )
	{		
		$xDoc = new DOMDocument();

		echo 'Parsing '.$filePath.PHP_EOL;
		if( $xDoc->loadXML( file_get_contents( $filePath ) ) ) {
			$xPath = new DOMXPath( $xDoc );
			
			$testCount = 0;
			$failureCount = 0;
			$errorCount = 0;
			$suiteName = 'Unknown'; // will be overwritten by each 'problem->problem_class' element below, which are all the same for an entire XML file

			$jSuiteAdded = false;

			$xProblems = $xPath->query( '/problems/problem' );
			foreach( $xProblems as $xProblem ) {
				
				// Check if there is a folder configured for the erratic file.
				// When found, get the max allowed errors from the configuration.
				// When not found, increment the error count for its parent folder.
				$file = self::getChildNodeText( $xPath, $xProblem, 'file' );
				$file = str_replace( 'file://$PROJECT_DIR$/', '.../', $file );
				$configFolder = self::getConfigFolder( $this->numberOfErrorsToIgnore, $file );
				if( $configFolder == null ) {
					$configFolder = self::getParentFolder( $file, 2 );
					if( !isset($this->errorCountExceedingFolders[$configFolder]) ) {
						$this->errorCountExceedingFolders[$configFolder] = 0;
					}
					$this->errorCountExceedingFolders[$configFolder] += 1;
					$numberOfErrorsToIgnore = 0;
					if( !isset( $this->totalFailureCount[$configFolder] ) ) {
						$this->totalFailureCount[$configFolder] = 0;
					}
				} else {
					$numberOfErrorsToIgnore = $this->numberOfErrorsToIgnore[$configFolder];
					$this->errorCountExceedingFolders[$configFolder] += 1;
				}

				// increment our total number of errors
				$this->totalFailureCount[$configFolder] += 1;

				// check if the total number of errors is greater then the number we should ignore
				// if not, we ignore them, if they are, we start parsing them
				if( $this->totalFailureCount[$configFolder] > $numberOfErrorsToIgnore ) {
					// is the jDoc updated already?
					if( $jSuiteAdded == false)	{
						$this->jDoc->appendChild( $this->jRoot );
						$jSuite = $this->jDoc->createElement( 'testsuite' );
						$this->jRoot->appendChild( $jSuite );
						$jSuiteAdded = true;
					}
					
					$jCase = $this->jDoc->createElement( 'testcase' );
					$jSuite->appendChild( $jCase );

					$line = self::getChildNodeText( $xPath, $xProblem, 'line' );
					$description = self::getChildNodeText( $xPath, $xProblem, 'description' );
					
					$caseName = $file.'#'.$line;
					$caseStatus = 'failure';
					$suiteName = self::getChildNodeText( $xPath, $xProblem, 'problem_class' );

					$jStatus = $this->jDoc->createElement( $caseStatus );
					$jStatus->setAttribute( 'message', $description  );
					$jCase->appendChild( $jStatus );

					$jCase->setAttribute( 'name', $caseName );
					$jCase->setAttribute( 'status', $caseStatus  ); // failure, skipped, success
					// L> ignoring attributes: assertions, time, classname

					$failureCount += 1;
				}
				$testCount +=1;
			}

			if( $jSuiteAdded == true)	{
				$jSuite->setAttribute( 'id', $this->suiteId );
				$jSuite->setAttribute( 'name', $suiteName );
				$jSuite->setAttribute( 'package', $package );
				$jSuite->setAttribute( 'tests', $testCount );
				$jSuite->setAttribute( 'failures', $failureCount );
				$jSuite->setAttribute( 'errors', $errorCount );
				$jSuite->setAttribute( 'skipped', 0 );
				// L> ignoring attributes: disabled, hostname, time, timestamp
			}
			
			$this->suiteId += 1;
			$this->totalTestCount += $testCount;
		}
	}
	
	/**
	 * Adds a testsuite node when the error count in certain subfolders exceed the maximum
	 * configured error count. This helps developers to identify which file has caused troubles.
	 */
	private function reportErrorsForMissingFolders()
	{
		$testCount = 0;
		$failureCount = 0;
		$errorCount = 0;
		$caseStatus = 'failure';
		$jSuiteAdded = false;
		
		// Iterate through all folders for which the error count has been exceeded.
		// Export those errors in the JUnit XML document structure.
		foreach( $this->errorCountExceedingFolders as $configFolder => $folderErrorCount ) {
			
			$message = 'There are '.$folderErrorCount.' errors reported for this folder. ';
			if( isset( $this->numberOfErrorsToIgnore[$configFolder] ) ) {
				if( $folderErrorCount > $this->numberOfErrorsToIgnore[$configFolder] ) {
					$message .= 'However, only '.$this->numberOfErrorsToIgnore[$configFolder].' errors are allowed. '.
							'You may either want to adjust the configuration in "'.__FILE__.'" '.
							'or better, solve all errors reported for this folder. ';
				} else {
					continue; // skip!
				}
			} else {
				$message .= 'However, there is no max error configuration for this folder. '.
					'You may either want to add a configuration to "'.__FILE__.'" '.
					'or better, solve all errors reported for this folder. ';
			}
			if( $jSuiteAdded == false ) {
				$this->jDoc->appendChild( $this->jRoot );
				$jSuite = $this->jDoc->createElement( 'testsuite' );
				$this->jRoot->appendChild( $jSuite );
				$jSuiteAdded = true;
			}
			$jCase = $this->jDoc->createElement( 'testcase' );
			$jSuite->appendChild( $jCase );
			
			$jStatus = $this->jDoc->createElement( $caseStatus );
			$jStatus->setAttribute( 'message', $message  );
			$jCase->appendChild( $jStatus );

			$jCase->setAttribute( 'name', $configFolder );
			$jCase->setAttribute( 'status', $caseStatus  ); // failure, skipped, success
			// L> ignoring attributes: assertions, time, classname

			$failureCount += 1;
		}
		
		if( $jSuiteAdded ) {
			$jSuite->setAttribute( 'id', $this->suiteId );
			$jSuite->setAttribute( 'name', 'Too many errors in folder' );
			$jSuite->setAttribute( 'package', '' );
			$jSuite->setAttribute( 'tests', $testCount );
			$jSuite->setAttribute( 'failures', $failureCount );
			$jSuite->setAttribute( 'errors', $errorCount );
			$jSuite->setAttribute( 'skipped', 0 );
			// L> ignoring attributes: disabled, hostname, time, timestamp

			$this->suiteId += 1;
			$this->totalTestCount += $testCount;
		}
	}
				
	
	/**
	 * Searches through the list of configured folders to see which one matches a given file.
	 * It returns the first best folder which path fits entirely into the file.
	 * Therefor assumed is that most specific folders are configured first, then the more global ones.
	 *
	 * @param integer[] $numberOfErrorsToIgnore List of configured folders to search (keys) each having a max error number (values).
	 * @param string $file
	 * @return string|null The first best found folder. NULL when none found.
	 */
	static private function getConfigFolder( $numberOfErrorsToIgnore, $file )
	{
		$foundFolder = null;
		foreach( array_keys( $numberOfErrorsToIgnore ) as $configFolder ) {
			$pos = strpos( $file, $configFolder ); // haystack, needle
			if( $pos === 0 ) {
				$folderLevels = self::getFolderLevels( $configFolder );
				$fileLevels = self::getFolderLevels( $file );
				if( $folderLevels >= 2 || $folderLevels == $fileLevels ) {
					$foundFolder = $configFolder;
					break;
				}
			}
		}
		return $foundFolder;
	}
	
	/**
	 * Determines the parent folder of a given file, for a specified depth.
	 * The depth is the number of subfolders counted from the project root (top-down).
	 * When there is no such depth, a parent folder with less depth is returned.
	 * It assumes the file is prefixed with '.../' which represents the project root.
	 *
	 * @param string $file
	 * @param integer $levels
	 * @param string Requested parent folder (prefixed with '.../')
	 */
	static private function getParentFolder( $file, $levels )
	{
		$parts = explode( '/', $file );
		array_shift( $parts ); // remove '...' from start
		array_pop( $parts ); // remove file name from end
		$retParts = array();
		for( $i = 0; $i < $levels; $i++ ) {
			if( count( $parts ) ) {
				$retParts[] = array_shift( $parts );
			}
		}
		$ret = implode( '/', $retParts );
		if( $ret ) {
			$ret .= '/';
		}
		return '.../'.$ret;
	}
	
	/**
	 * Determines the subfolder count between the file and the project folder.
	 * 
	 * @param string $file
	 * @return integer Number of subfolders.
	 */
	static private function getFolderLevels( $file )
	{
		// Count -2 because:
		// - the '.../' prefix is not counted
		// - the file itself is not counted
		return count( explode( '/', $file ) ) - 2;
	}
	
	/**
	 * Retrieves the text of a child node of a given parent node.
	 *
	 * @param DOMXPath $xPath
	 * @param DOMNode $parentNode
	 * @param string $childNodeName
	 * @return string The text of the child node.
	 */
	static private function getChildNodeText( $xPath, $parentNode, $childNodeName )
	{
		$val = $xPath->query( $childNodeName.'/text()', $parentNode );
		if( $val && $val->length > 0 ) {
			$val = $val->item(0)->nodeValue;
		}
		return $val ? $val : '';
	}
}

// Validate CLI arguments.
$usage = 'USAGE: '.$GLOBALS['argv'][0].' <input folder path to scan for xml files> <output file path to write jUnit file> <number of errors we ignore>';
if( !isset($GLOBALS['argv'][1]) ) {
	echo 'ERROR: Import folder path argument missing.'.PHP_EOL;
	echo $usage.PHP_EOL;
	exit(1);
}
$folderPath = $GLOBALS['argv'][1];
$folderPath = str_replace( '"', '', $folderPath );
if( !is_dir( $folderPath ) ) {
	echo 'ERROR: Not a valid import folder path provided: '.$folderPath.PHP_EOL;
	echo $usage.PHP_EOL;
	exit(1);
}

if( !isset($GLOBALS['argv'][2]) ) {
	echo 'ERROR: Export file path argument missing.'.PHP_EOL;
	echo $usage.PHP_EOL;
	exit(1);
}
$jUnitFilePath = $GLOBALS['argv'][2];
$jUnitFilePath = str_replace( '"', '', $jUnitFilePath );
if( !is_dir( dirname($jUnitFilePath) ) ) {
	echo 'ERROR: Parent folder of export file path does not exists: '.$jUnitFilePath.PHP_EOL;
	echo $usage.PHP_EOL;
	exit(1);
}

if( !isset($GLOBALS['argv'][2]) ) {
	echo 'ERROR: Number of errors to ignore missing.'.PHP_EOL;
	echo $usage.PHP_EOL;
	exit(1);
}

// Run the converter.
$converter = new PhpStormXml2JunitXmlConverter();
$converter->convertFilesInFolder( $folderPath, $jUnitFilePath );

/*
Example of phpStorm Code Inspector XML output:
	<problems>
		<problem>
			<file>file://$PROJECT_DIR$/Enterprise/server/bizclasses/BizQuery.class.php</file>
			<line>71</line>
			<module>Enterprise</module>
			<entry_point TYPE="file" FQNAME="file://$PROJECT_DIR$/Enterprise/server/bizclasses/BizQuery.class.php" />
			<problem_class severity="WARNING" attribute_key="WARNING_ATTRIBUTES">Parameter type</problem_class>
			<description>Parameter '$areas' type is not compatible with declaration</description>
		</problem>
		...
Example of JUnit XML format:
	<testsuites disabled="" errors="" failures="" name="" tests="" time="">
		<testsuite disabled="" errors="" failures="" hostname="" id="" name="" package="" skipped="" tests="" time="" timestamp="">
			<properties>
				<property name="" value=""/>
				<property name="" value=""/>
			</properties>
			<testcase assertions="" classname="" name="" status="" time="">
				<skipped/>
				<error message="" type=""/>
				<error message="" type=""/>
				<failure message="" type=""/>
				<failure message="" type=""/>
				<system-out/>
				<system-out/>
				<system-err/>
				<system-err/>
			</testcase>
			...
*/