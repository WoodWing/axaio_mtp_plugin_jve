<?php

set_time_limit(3600);

/**
* Implementation of hook_xmlrpc()
*/

function ww_enterprise_xmlrpc() {

    $xmlrpc = array();

    $xmlrpc[] = array(
    'enterprise.nodePublish',
    'ww_enterprise_xmlrpc_nodePublish',
    array ('struct', 'struct', 'struct', 'array', 'array', 'array', 'array', 'array',  'int', 'int'),
    t(''),
    );

    $xmlrpc[] = array(
    'enterprise.nodeUpdate',
    'ww_enterprise_xmlrpc_nodeUpdate',
    array ('struct', 'struct', 'int', 'struct', 'array', 'array', 'array'),
    t(''),
    );

    $xmlrpc[] = array(
    'enterprise.nodeGetInfo',
    'ww_enterprise_xmlrpc_nodeGetInfo',
    array ('struct', 'int'),
    t(''),
    );

    $xmlrpc[] = array(
    'enterprise.nodeUnpublish',
    'ww_enterprise_xmlrpc_nodeUnpublish',
    array ('struct', 'struct', 'int', 'array'),
    t(''),
    );

    $xmlrpc[] = array(
    'enterprise.testConfig',
    'ww_enterprise_xmlrpc_testConfig',
    array ('struct', 'struct'),
    t(''),
    );

    return $xmlrpc;
}

/**
* Implementation of hook_block()
*/
function ww_enterprise_block($op = 'list', $delta = 0, $edit = array())
{
	$edit = $edit; // keep analyzer happy
	switch ($op) {
        case 'list':
            // If $op is "list", we just need to return a list of block descriptions.
            $blocks[0]['info'] = t('Attached images');
            $blocks[1]['info'] = t('Attached images');
            return $blocks;
        case 'configure':
            // Do nothing
            return null;
        case 'save':
            // Do nothing
            return null;
        case 'view':
            switch ($delta) {
                case 1:
                    $block['subject'] = t('Attached images');
                    $block['content'] = block_ww_enterprise_contents(1);
                    break;
            }
            return $block;
    }
    return null;
}

/**
* Implementation of hook_contents()
*/
function block_ww_enterprise_contents($which_block)
{
    if ($which_block == 1) {
        // Load attached images
        if ( arg(0) == 'node' && is_numeric(arg(1)) && ! arg(2) ) { // basic url check
            $node = node_load(arg(1)); //get node id
            $sql = db_query('SELECT iid FROM {image_attach} WHERE nid=%d', $node->nid); // select all the images attached to this node
            $output = "";
            while ( ($data = db_fetch_object($sql)) ) { // for each image attached to this text node
                $image = node_load($data->iid); // open image node
                $output .= '<div class="image-attach">';
                $output .= l(image_display($image, 'thumbnail'), "node/$data->iid", array('html' => TRUE)); // show a link to the image node
                $output .= '</div>'."<br>\n"; //
            }
            return $output;
        }
    }
    return null;
}

// Callback functions

// !!! A good queue processor should be written and used instead of importVideo / importAudio functions in production

/**
* Import video node - TBD
*
* @param int $node Drupal node ID
* @param binary $content File data
* @param string $fileName Name of the source file
* @param string $ratio Video ratio ('3_4' for 3:4 and '16_9' for 16:9)
* @param string $tempDir Path to temporary directory on web server
* @param string $drupalDir Path to Drupal directory on web server
*
* @return int node id
*
*/
function importVideo($node, $content, $fileName, $ratio, $tempDir, $drupalDir)
{
	// keep analyzer happy
	$node = $node;
	$content = $content;
	
	$return = 0;
    switch ($ratio) {
        case '3_4':
            system ("/usr/bin/ffmpeg -i /var/www/".$tempDir."/".$fileName." -b 200000 -r 25 -s 320x240 -y -ar 22050 /var/www/".$drupalDir.$fileName.".flv", $return);
            break;
        case '16_9':
            system ("/usr/bin/ffmpeg -i /var/www/".$tempDir."/".$fileName." -b 200000 -r 25 -s 320x180 -padtop 30 -padbottom 30 -y -ar 22050 /var/www/".$drupalDir.$fileName.".flv", $return);
            break;
    }
    if ($return || !file_exists($drupalDir.$fileName.".flv")) {
        // Report error - TBD
        return;
    } // else Create Drupal node - TBD
}

/**
* Import audio node - TBD
*
* @param int $node Drupal node ID
* @param binary $content File data
* @param string $fileName Name of the source file
* @param string $tempDir Path to temporary directory on web server
* @param string $drupalDir Path to Drupal directory on web server
*
* @return int node id
*
*/
function importAudio($node, $content, $fileName, $tempDir, $drupalDir)
{
	// keep analyzer happy
	$node = $node;
	$content = $content;
	
	$return = 0;
	system ("/usr/bin/lame --mp3input -b 96 /var/www/".$tempDir."/".$fileName." /var/www/".$drupalDir.$fileName.".mp3", $return);
    if ($return || !file_exists($drupalDir.$fileName.".mp3")) {
        // Report error - TBD
        return;
    } // else Create Drupal node - TBD
}

/**
 * Logs on to Drupal and sets the global user
 * Throws an Exception if the logon fails.
 *
 * @param array $logOnParams
 */
function ww_enterprise_logOn ($logOnParams)
{
	$password = base64_decode($logOnParams['password']);
	// log on
	$user = user_authenticate(array('name' => $logOnParams['username'] , 'pass' => $password));

	if (! $user->uid) {
		throw new Exception(t('Error logging on'));
	}
}

function deleteOldPreviews()
{
	global $user;

	$timeLimit = time() - 1 * 60 * 60; // 1 hour
	// query nodes that aren't published and from the ww_enterprise user older than a specific time
	$node_result = db_query('SELECT nid FROM {node} WHERE status = 0 AND uid = %d AND created < %d', $user->uid, $timeLimit);
	while ( ($node = db_fetch_object($node_result)) ) {
		node_delete($node->nid);
	}
}

/**
 * Set only new keywords in keywords key/value array
 *
 * @param array $keywords resulting keyword key/value array e.g. array("keyword1"=>1, "keyword2"=>1)
 * @param array $array new values (e.g. array("keyword1", "keyword2") )
 */
function ww_enterprise_setKeywords (&$keywords, $array)
{
	foreach ($array as $key) {
		if (! isset($keywords[$key])) {
			$keywords[$key] = true;
		}
	}
}

/**
 * Import images in to Drupal as image nodes.
 *
 * @param array $images
 * @param array $idArray
 * @return array of image nodes
 
function importImages ($images, $publish, &$idArray, &$keywords)
{
	$imageNodes = array();
	foreach ($images as $image) {
		// in case of an update the iid is set and the old image node can be removed
		if (isset($image['iid']) && $image['iid']) {
			node_delete($image['iid']);
		}

		$dest = tempnam(realpath(file_directory_temp()), $image['name']) . $image['ext'];
		$filePath = file_save_data(base64_decode($image['contents']), $dest);
		$inode = image_create_node_from($filePath, $image['name']);
		if ($inode) {
			if (! $publish) {
				// set status to unpulished
				$inode->status = $publish;
				node_save($inode);
			}
			$imageNodes[] = $inode;
			$idArray[$image['enterprise_id']] = $inode->nid;
			ww_enterprise_setKeywords($keywords, $image['keywords']);
		}
	}

	return $imageNodes;
}
*/

/**
 * Create image nodes and attach them to the node.
 *
 * @param array $file the incomming file 
 * @param object &$fileObj file object
 * @param object &$node node object
 */
function ww_enterprise_attachImage ($file, &$fileObj, &$node)
{
	$id = 0;
	// in case of an update the iid is set and the old image node can be removed
	if (isset($file['iid']) && $file['iid']) {
		node_delete($file['iid']);
	}
	$inode = image_create_node_from($fileObj->filepath, $file['name']);
	if ($inode) {
		// delete from files table because image_create_node_from has moved file and created new entry
		//TODO delete or not delete? 
		//db_query('DELETE FROM {files} WHERE fid = %d', $fileObj->fid);
		if (! $publish) {
			// set status to unpulished
			//TODO check if can set the status easier
			$inode2 = node_load($inode->nid);
			$inode2->status = $publish;
			node_save($inode2);
		}
		$id = $inode->nid;
		// only first image is an image attachment
		if (! $node->iid){
			$node->iids = array('- None -', $id);
			$node->iid = $id;
		}
		
  	//Add the all images to the node
		$fileObj->list = 0;
		$fileObj->new = TRUE;
		$node->files[$fileObj->fid] = $fileObj;
	}
	
	return $id;
}

/**
 * Get all <img> elements from the body of the node, which have an id that starts with "ent_"
 * Replace their (enterprise internal) src with a drupal src.
 */
function ww_enterprise_parse_images( &$node, $idArray, $imageNodes )
{
	$ww_images = array();
	$ww_newimages = array();
	
	// regular express our way through every enterprise image object.
	$pattern = '/<img[^>]*id=\"ent_([^\"]*)[^>]*src=\"([^\"]*)[^>]*>/i';
	$pattern_result = array();	// elements: 0 = the full image element (<img>), 1 = the image id (without the "ent_" prefix), 2 = the image src.
	
	preg_match_all( $pattern, $node->body, $pattern_result );
	
	for($i=0; $i<count($pattern_result[0]); $i++)
	{
		$ww_images[] = $pattern_result[0][$i]; 		// copy the found image to ww_images array
		$iId = $idArray[$pattern_result[1][$i]];	// get the image node id
		$imagenode = node_load($iId);									// get the image node by id
		
		// create the new image url
		$ww_newimage_src = _ww_enterprise_getURL(null,false)."/".$imagenode->images['_original'];
		
		// build the replace array
		$ww_newimages[] = str_replace($pattern_result[2][$i], $ww_newimage_src, $pattern_result[0][$i]);
	}
	
	for($i=0; $i<count($ww_images); $i++)
	{
		$node->body = str_replace($ww_images[$i], $ww_newimages[$i], $node->body);
	}
}

/**
 * attach all other files to the node. 
 *
 * @param array $file the incomming file 
 * @param object &$fileObj file object
 * @param object &$node node object
 */
function ww_enterprise_attachFile ($file, &$fileObj, &$node)
{
	// extra properties for upload module
	$fileObj->list = 1;
	$fileObj->new = TRUE;
	$node->files[$fileObj->fid] = $fileObj;

	return $fileObj->fid;
}

/**
 * Attach incoming files to the node
 *
 * @param array $files
 * @param 
 * @param 
 * @param 
 * @param 
 *
 * TODO: use the publish parameter
 */
function ww_enterprise_attachFiles ($files, $publish, &$idArray, &$keywords, &$node)
{
	static $imageTypes = array('image/jpeg' => true, 'image/gif' => true, 'image/png' => true);
	
	// remove current attachments	
	$node->iid = null;
	foreach ($node->files as &$file){
		$file->remove = TRUE;
	}
	
	foreach ($files as &$file) {
		$fid = isset($file['fid']) ? intval($file['fid']) : 0;
		$fileObj = null;
		if ( $fid > 0 ) {
			$fileObj = db_fetch_object(db_query('SELECT * FROM {files} WHERE fid = %d', $fid));
		} else {
			$data = base64_decode($file['contents']);
			$fileObj = ww_enterprise_createFile($data, $file['name'] . $file['ext'], $file['type']);
		}
		$id = 0;
		if (isset($imageTypes[$file['type']])){
			// it's an image
			$id = ww_enterprise_attachImage($file, $fileObj, $node);
		} else {
			// not an image, set as attachment
			$id = ww_enterprise_attachFile($file, $fileObj, $node);
		}
		$idArray[$file['enterprise_id']] = $id;
		ww_enterprise_setKeywords($keywords, $file['keywords']);
	}
}

/**
 * Import text elements in Drupal
 *
 * @param array $dossierProps
 * @param array $textElements
 * @param unknown_type $publish
 * @param unknown_type $promote
 * @param object $oldNode null if a new node has to be created
 * @param string $attachImageId
 * @param array $fileAttachments
 * @param array $keywords reference
 * @return object node or null if there's an error
 */
function importTextElements($dossierProps, $textElements, $publish, $promote, $oldNode, $attachImageId, $fileAttachments, &$keywords, &$idArray=array(), $imageNodes=array())
{
	global $user;

	// Walk thru text elements to get head and body:
	$head = null;
    $teaser = null;
    $writer = null;
    $category = '';
    $keywords = array();
    foreach( $textElements as $te ) {
    	if( array_key_exists('body', $te ) ) {
            $body = $te['body'];
            // writer is the writer of the body
            $writer = $te['writer'];
        } else if( array_key_exists('head', $te ) ) {
            $head = strip_tags($te['head']);
        } else if( array_key_exists('intro', $te ) ) {
            $teaser = $te['intro'];
        }
    	ww_enterprise_setKeywords($keywords, $te['keywords']);
    }

	// Test is contenttype is known. If not, raise exception and make sure decent error shown by Enterprise
	$types = node_get_types('names');
	if(!$types[$dossierProps['ContentType']]) {
		throw new Exception(t('Failed to publish, the content type "!type" does not exsist in the current Drupal installation!', array('!type' => $dossierProps['ContentType'])));
	} 
	
	// TODO #WWPC, this test should be more sophisticated
	//    if (is_null($head) || is_null($body) || empty($head) || empty($body)){
	//    	throw new Exception(t('Cannot publish node with an empty head or body!'));
	//   }
    if( is_null($head) || is_null($body) || empty($head) || empty($body)){
    	if( $dossierProps['ContentType'] == 'events_conference_news' ) {
    		throw new Exception(t('Cannot publish node with an empty head or body!'));
    	}
    	// If no explicit head specified we fallback on description or name:
    	if( is_null($head) ) {
    		if( isset($dossierProps['Description']) && !empty($dossierProps['Description']) ) {
	    		$head = $dossierProps['Description'];
			} else {
	    		$head = $dossierProps['Name'];
	    	}
    	}
    	if( is_null($body) ) {
	    	$body = '';
	    }
    }
    
  // Drupal body is teaser plus body seperated by "<!--break-->"
  if( !empty($teaser) ) {
	  $body = $teaser . "\n<!--break-->\n" . $body;
	}
	
	// find taxonomy for Keywords
	$taxonomy = array();
	$vid = variable_get('ww_enterprise_keywords_vocabulary', false);
	
	if($vid) {
		$vocabulary_tags = taxonomy_vocabulary_load($vid);
		
		$keys = array_keys($keywords);
		$taxonomy[$vocabulary_tags->name] = array($vid => implode(',', $keys));
	}
	
	// Multiple tags, each with their vocabulary can be passed. This are named 'Vocabularry1'...'VocabularryN' and 'Tags1'...'Tags'N'
	$vocN = 1;
	while( $vocN ) {
		// If vocabulary passed we use that to assign tags. search vocabulary id:
		$vocabularyId = 0;
		if( isset($dossierProps['Vocabulary'.$vocN]) && isset( $dossierProps['Tags'.$vocN] ) ) {
			$vocabularyId = db_result(db_query("SELECT vid FROM {vocabulary} WHERE name='%s'", $dossierProps['Vocabulary'.$vocN]) );
			if( $vocabularyId  ){
				if( $vocN == 1 ) {
					$taxonomy['tags'] = array($vocabularyId => implode( ',',$dossierProps['Tags'.$vocN]) ) ;
				} else {
					$taxonomy['tags'][$vocabularyId] = implode( ',',$dossierProps['Tags'.$vocN] );
				}
			}
			$vocN++;
		} else {
			// Not found, set $vocN to 0 to stop the while
			$vocN = 0;
		}
	}
	
	if ($oldNode) {
		// Update node
		$node = $oldNode;
		$node->status = $publish;
		$node->title = $head;
		$node->body = $body;
		$node->teaser = $teaser;
		$node->writer = $writer;
		$node->taxonomy = $taxonomy;
		$node->changed = time();
	} else {
		// If promote is not set we get default from content type:
		$node_options = variable_get('node_options_'. $dossierProps['ContentType'], array());
		$promote = in_array('promote', $node_options);
		
		// new node
		$edit = array( // this is the node array used with node_save call
	    	'type' => $dossierProps['ContentType'], // type of the node
		    'uid' => $user->uid, // user id who published it
		    'name' => $user->name, // username who published it, we need it because $user can be administrator
		    'status' => $publish, // status (publish / do not publish)
		    'promote' => $promote, // show on title page
		    'title' => $head, // header
		    'body' => $body, // body
		    'teaser' => $teaser, // teaser
		    'writer' => $writer, // writer
		    'taxonomy' => $taxonomy, // category
		    'format' => FILTER_HTML_ESCAPE,
				'comment' => COMMENT_NODE_READ_WRITE,
				'changed' => time(),
	    );
	    
	    node_validate($edit); // validate node
	    $errors = form_get_errors();
	    
	    if ( $errors ) {
	    	throw new Exception(t('Error validating node: %errors', array('%errors'=>implode("\n", array_values($errors)))));
	    }

	    $node = node_submit($edit); // submit node...
	}
	
	// Handle the attachements and repair inline images. 
	ww_enterprise_attachFiles($fileAttachments, $publish, $idArray, $keywords, $node);
	ww_enterprise_parse_images( $node, $idArray, $imageNodes );
	
	// Rebuild the teaser to rebuild broken images
	$node->teaser = node_teaser($node->body);
  node_save($node); //... and save it so we have node id
  
  return $node;
}

/**
 * Return the (preview) URL of the node
 *
 * @param int $nid node id
 * @param boolean $preview true if preview URL else false
 * @return string complete URL
 */
function _ww_enterprise_getURL ($nid, $preview)
{
	// build url
	global $base_url;

	// remove :80 from base url, xmlrpc client on Enterprise side adds this to SERVER_HOST :(
	$url = preg_replace('|^http://([^/]*):80/|', 'http://$1/', $base_url, 1);
	
	if( $nid == null )
		return $url;
		
	if ($preview) {
		$url .= '/?q=ww_enterprise/' . $nid;
	} else {
		$url .= '/?q=node/' . $nid;
	}
	
	return $url;
}

/**
* Insert new Drupal text node. Create image nodes. Link image nodes to newly created text node.
*
* @param array $dossierProps
* @param array $textelements
* @param array $images
* @param array $videos
* @param array $audios
* @param array $hyperlinks
* @param int $promote
* @param int $publish
*
* @return array
* Returns array:
* nodeId - ID of newly created Drupal node
* imagesIdArray - array of IDs of newly created Image nodes: $iid => $filename
*
*/

function ww_enterprise_xmlrpc_nodePublish ($logOnParams, $dossierProps, $textelements, $images, $videos, $audios, $hyperlinks, $promote, $publish)
{
	// keep analyzer happy
	$audios = $audios;
	$hyperlinks = $hyperlinks;
	
	$result = null;

	try {
		ww_enterprise_logOn($logOnParams);

		deleteOldPreviews();
		if ($promote == "2") {
			$promote = "0";
		}

		// id array that maps Enterprise ids to Drupal ids
		$idArray = array();
		// array to keep unique keywords ( each entry like "keyword"=> 1 )
		$keywords = array();

		$node = importTextElements($dossierProps, $textelements, $publish, $promote, null, $iid, $videos, $keywords, $idArray, $imageNodes);
		
		if ($node) {
			watchdog('content',
				t('@type: inserted %title.',
					array('@type' => t($node->type) , '%title' => $node->title)), array(),
				WATCHDOG_NOTICE, l(t('view'), 'node/' . $node->nid));

			$url = _ww_enterprise_getURL($node->nid, $publish != '1');

			$result = array('nodeId' => $node->nid , 'url' => $url , 'idArray' => $idArray);
		}
	} catch (Exception $e) {
    	watchdog('content', $e->getMessage(), array(), WATCHDOG_ERROR);
		$result = array('Errors'=>array($e->getMessage()));
	}

	return $result;
}

/**
* Update existing Drupal text node. Create or update image nodes. Link these image nodes to Drupal node.
*
* @param object $dossierProps
* @param array $textelements
* @param array $images
*
* @return array
* Returns array:
* nodeId - ID of Drupal node
* imagesId - array of IDs of updated/inserted Image nodes
*
*/

function ww_enterprise_xmlrpc_nodeUpdate ($logOnParams, $nid, $dossierProps, $textelements, $images, $otherFiles)
{
	$result = null;

	try {
		ww_enterprise_logOn($logOnParams);

		// check if node exists
		$node = node_load(array('nid'=>$nid));

		if (!$node){
			throw new Exception(t('Could not find node'));
		}
		// id array that maps Enterprise ids to Drupal ids
		$idArray = array();
		// array to keep unique keywords ( each entry like "keyword"=> 1 )
		$keywords = array();

		$node = importTextElements($dossierProps, $textelements, null, null, $node, $iid, $otherFiles, $keywords, $idArray, $imageNodes);

		if ($node) {
			watchdog('content',
				t('@type: updated %title.',
					array('@type' => t($node->type) , '%title' => $node->title)), array(),
				WATCHDOG_NOTICE, l(t('view'), 'node/' . $node->nid));

			$result = array('nodeId' => $node->nid , 'idArray' => $idArray);
		}
	} catch (Exception $e) {
    	watchdog('content', $e->getMessage(), array(), WATCHDOG_ERROR);
		$result = array('Errors' => array($e->getMessage()));
	}

	return $result;
}

function ww_enterprise_xmlrpc_nodeGetInfo ($nid)
{
	$result = array('Views' => 0 , 'Rating' => null , 'Raters' => 0 , 'CommentsCount' => 0 , 
		'Comments' => array(), 'URL' => '');
	// get statistics
	if (module_exists('statistics')) {
		$statistics = statistics_get($nid);
		if ($statistics) {
			$result['Views'] = $statistics['totalcount'];
			// extra property, not fully supported in Content Station
			$result['DayViews'] = intval($statistics['daycount']);
		}
	}
	// get comments
	if (module_exists('comment')){
		$result['CommentsCount'] = comment_num_all($nid);
		$qr = db_query('SELECT comment FROM {comments} WHERE nid = %d ORDER BY timestamp', array($nid));
    	while ( ($comment = db_fetch_array($qr)) ){
    		$result['Comments'][] = $comment['comment'];
    	}
	}

	// get rating
	if (module_exists('votingapi')) {
		$votes = votingapi_select_results(
			array('content_type' => 'node' , 'content_id' => $nid , 'value_type' => 'percent' , 
				'tag' => 'vote'));
		foreach ($votes as $vote) {
			if ($vote['function'] == 'average') {
				// scale from 0 to 5 in Enterprise
				$result['Rating'] = ($vote['value'] / 100) * 5;
			} else 
				if ($vote['function'] == 'count') {
					$result['Raters'] = $vote['value'];
				}
		}
	}
	// get URL
	$result['URL'] = _ww_enterprise_getURL($nid, false);
	
	return $result;
}

function ww_enterprise_xmlrpc_nodeUnpublish ($logOnParams, $nid, $imageIDs)
{
	$result = $nid;

	try {
		ww_enterprise_logOn($logOnParams);

                /**
                 * Only delete the node if there are no comments else unpublish
                 */
                if(comment_num_all($nid) > 0) {
                    $node = node_load($nid);
                    node_unpublish_action($node);
                    node_save($node);
                } else {
                    // for now delete all images
                    foreach ($imageIDs as $imageID) {
                        node_delete($imageID);
                    }
                    // delete main node if node has no content
                    node_delete($nid);
                }

	} catch (Exception $e) {
    	watchdog('content', $e->getMessage(), array(), WATCHDOG_ERROR);
		$result = array('Errors' => array($e->getMessage()));
	}

	return $result;
}

/**
 * Test the Drupal configuration.
 * This function tests only the logon parameters now. This can be extended in the future
 *
 * @param array $logOnParams
 * @return array
 */
function ww_enterprise_xmlrpc_testConfig ($logOnParams)
{
	$result = array();

	try {
		ww_enterprise_logOn($logOnParams);

	} catch (Exception $e) {
    	watchdog('content', $e->getMessage(), array(), WATCHDOG_ERROR);
		$result = array('Errors' => array($e->getMessage()));
	}

	return $result;
}

/**
 * Implementation of hook_menu().
 */
function ww_enterprise_menu ()
{
	$items['admin/settings/ww_enterprise'] = array(
		'title' => t('WoodWing Enterprise'),
		'description' => t('Administrator WoodWing Enterprise'),
		'page callback' => 'drupal_get_form',
		'page arguments' => array('ww_enterprise_admin_settings'),
		'access arguments' => array('administer site configuration'),
		'type' => MENU_NORMAL_ITEM,
		'file' => 'ww_enterprise.admin.inc',
	);

	// Handle file uploads
	$items['ww_enterprise/upload'] = array(
		'page callback' => 'ww_enterprise_upload', 
		'access callback' => 'ww_enterprise_page_access', 
		'access arguments' => array('upload' , 1), 
		'type' => MENU_CALLBACK
	);

	return $items;
}

function ww_enterprise_page_access ($op, $node, $account = NULL)
{
	//TODO check if requested from Enterprise server
	$op = $op;
	$node = $node;
	$account = $account;

	return TRUE;
}

/**
 * Title callback.
 */
function ww_enterprise_title ($node)
{
	return $node->title;
}

/**
 * Menu callback; view a single node.
 */
function ww_enterprise_page_view ($node, $cid = NULL)
{
	//TODO generate random key and check it here as identification
	$return = null;
	$return = $return; // keep analyzer happy
	// login as Enterprise user to show unpublished images too
	global $user;
	// backup user
	$userBackup = $user;
	try {
		$account = user_load(array('uid' => $node->uid));
		user_external_login($account);
		drupal_set_title(check_plain($node->title));
		$return = node_show($node, $cid);
	} catch (Exception $e) {
		watchdog('content', $e->getMessage(), array(), WATCHDOG_ERROR);
	}

	// restore user
	$user = $userBackup;

	return $return;
}

/**
 * Save files to Drupal system
 *
 * @param array $files
 * @return array of file objects with fid as keys
 */
function ww_enterprise_saveFiles (array $files)
{
	global $user;
	$result = array();

	foreach ($files as $file) {
		// attach file
		// check if file has been uploaded already
		$fid = isset($file['fid']) ? intval($file['fid']) : 0;
		if ( $fid > 0 ) {
			$fileObj = db_fetch_object(db_query('SELECT * FROM {files} WHERE fid = %d', $fid));
		} else {
			$data = base64_decode($file['contents']);
			$fileObj = ww_enterprise_create_file($data, $file['name'] . $file['ext'], $file['type']);
		}
		// extra properties for upload module
		$fileObj->list = 1;
		$fileObj->new = TRUE;
		$result[$fileObj->fid] = $fileObj;
	}

	return $result;
}

function ww_enterprise_createFile($data, $fileName, $fileType)
{
	$fileObj = new stdClass();
	$fileObj->filename = $fileName; //$file['name'] . $file['ext'];
	$filePath = file_save_data($data,
		file_create_filename($fileObj->filename, file_directory_path()));
	$fileObj->fid = 0;
	$fileObj->uid = $user->uid;
	$fileObj->filepath = $filePath;
	$fileObj->filemime = $fileType; //$file['type'];
	$fileObj->filesize = strlen($data);
	$fileObj->status = FILE_STATUS_TEMPORARY;
	$fileObj->timestamp = time();
	drupal_write_record('files', $fileObj);
	
	return $fileObj;
}

function ww_enterprise_upload()
{
	$dom = new DOMDocument('1.0', 'UTF-8');
	$uploadResponseEl = $dom->createElement('UploadResponse');
	try {
		ww_enterprise_logOn($_POST);
		$file = file_save_upload('upload', array(), file_directory_path());
		$fidEl = $dom->createElement('fid');
		$fidEl->appendChild($dom->createTextNode($file->fid));
		$uploadResponseEl->appendChild($fidEl);
	} catch (Exception $e) {
		watchdog('content', $e->getMessage(), array(), WATCHDOG_ERROR);
		$errEl = $dom->createElement('error');
		$errEl->appendChild($dom->createTextNode($e->getMessage()));
		$uploadResponseEl->appendChild($errEl);
	}
	$dom->appendChild($uploadResponseEl);
	print $dom->saveXML();
}

?>
