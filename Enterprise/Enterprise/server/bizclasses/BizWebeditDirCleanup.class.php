<?php
/**
 * @package   Enterprise
 * @subpackage BizClasses
 * @since      v10.4.1
 * @copyright   WoodWing Software bv. All Rights Reserved.
 *
 * Removes old files from the WEBEDITDIR folder. Files can remain in the folder due to crashes of client applications
 * and because log files are generated by InDesign Server.
 * Files that are older than value set in AUTOCLEAN_WEBEDITDIR_DAYS ( in days ) will be removed
 * when Server Job is executed.
 */

require_once BASEDIR.'/server/bizclasses/BizServerJobHandler.class.php';

class BizWebeditDirCleanup extends BizServerJobHandler
{

	/**
	 * Implementation of BizServerJobHandler::getJobConfig() abstract.
	 * Called by BizServerJob when the Health Check or Server Job admin pages are run.
	 *
	 * @param ServerJobConfig $jobConfig Configuration to update by the handler.
	 */
	public function getJobConfig( ServerJobConfig $jobConfig )
	{
		$jobConfig->SysAdmin = true;
		$jobConfig->Recurring = true;
	}

	/**
	 * Checks whether the AutoCleanWebEditFolder job is enabled.
	 *
	 * AutoCleanWebEditFolder job is enabled when AUTOCLEAN_WEBEDITDIR_DAYS is set to a value more than 0.
	 *
	 * @return bool
	 */
	public static function isWebEditDirCleanupEnabled()
	{
		$cleanupJobEnabled = false;
		do {
			if( AUTOCLEAN_WEBEDITDIR_DAYS <= 0 ) {
				break;
			}

			require_once BASEDIR.'/server/bizclasses/BizServerJobConfig.class.php';
			$bizJobConfig = new BizServerJobConfig();
			if( !$bizJobConfig->isJobRegisteredAndAssigned( 'AutoCleanWebEditFolder' ) ) {
				break;
			}

			$cleanupJobEnabled = true;
		} while( false );

		return $cleanupJobEnabled;
	}

	/**
	 * Creates a server job that can be called later on by the background process.
	 *
	 * @param boolean $putIntoQueue True to insert the job into job queue, False to just return the constructed job object.
	 * @return ServerJob $job Job that is constructed.
	 */
	public function createJob( $putIntoQueue = true )
	{
		require_once BASEDIR.'/server/dataclasses/ServerJob.class.php';
		$job = new ServerJob();
		// No objectid and object version since cleanup is not bound to one object.
		$job->JobType = 'AutoCleanWebEditFolder';
		self::serializeJobFieldsValue( $job );

		if( $putIntoQueue ) {
			// Push the job into the queue (for async execution)
			require_once BASEDIR.'/server/bizclasses/BizServerJob.class.php';
			$bizServerJob = new BizServerJob();
			$bizServerJob->createJob( $job );
		}

		return $job;
	}

	/**
	 * Clean-up the WEBEDIT directory.
	 *
	 * In the WebEdit directory old files remain due to crashes of InDesign Server but also due to article workspaces
	 * that are not cleaned because Content Station is not properly ended. Article workspaces are created within the
	 * WebEdit folder. Lastly the WebEdit directory contains log files generated by InDesign Server.
	 *
	 * @param ServerJob $job
	 */
	public function runJob( ServerJob $job )
	{
		self::unserializeJobFieldsValue( $job );
		require_once BASEDIR.'/server/utils/FolderUtils.class.php';
		FolderUtils::scanDirForFiles( $this, substr( WEBEDITDIR, 0, -1 ) ); // Remove trailing slash.
		require_once BASEDIR.'/server/dataclasses/ServerJobStatus.class.php';
		$job->JobStatus->setStatus( ServerJobStatus::COMPLETED );
		// Uncomment to pick up same job again and again (for heavy debugging only)
		// $jobStatus->setStatus( ServerJobStatus::PLANNED );
		self::serializeJobFieldsValue( $job );
	}

	/**
	 * Prepare ServerJob (parameter $job) to be ready for use by the caller.
	 *
	 * The parameter $job is returned from database as it is (i.e some data might be
	 * serialized for DB storage purposes ), this function make sure all the data are
	 * un-serialized.
	 * Mainly called when ServerJob Object is passed from functions in BizServerJob class.
	 *
	 * @param ServerJob $job
	 */
	private static function unserializeJobFieldsValue( ServerJob $job )
	{
		// Make sure to include the necessary class file(s) here, else it will result into
		// 'PHP_Incomplete_Class Object' during unserialize.
		require_once BASEDIR.'/server/interfaces/services/wfl/DataClasses.php';
		if( !is_null( $job->JobData ) ) {
			$job->JobData = unserialize( $job->JobData );
		}
	}

	/**
	 * Make sure the parameter $job passed in is ready for used by database.
	 *
	 * Mainly called when ServerJob Object needs to be passed to functions in BizServerJob class.
	 *
	 * @param ServerJob $job
	 */
	private static function serializeJobFieldsValue( ServerJob $job )
	{
		if( !is_null( $job->JobData ) ) {
			$job->JobData = serialize( $job->JobData );
		}
	}

	/**
	 * Called by the FolderUtils class, which iterates through the subfolder and calls this function.
	 * When the given file ($filePath) is older than the clean-up setting, this function
	 * deletes it. See deleteFile() function for more details.
	 *
	 * @param string $filePath Full file path of the file.
	 * @param integer $level Current ply in folder structure of recursion search.
	 */
	public function iterFile( $filePath, /** @noinspection PhpUnusedParameterInspection */
	                          $level )
	{
		$status = stat( $filePath );
		$time = time();
		if( $status['ctime'] < ( time() - ( AUTOCLEAN_WEBEDITDIR_DAYS * 24 * 3600 ) ) ) {
			$this->deleteFile( $filePath );
		}
	}

	/**
	 * Deletes a given file from the WEBEDIT folder.
	 *
	 * When it cannot be deleted due to any problem (e.g. a file access problem), an ERROR entry is created in server
	 * logging. When the file does not exists, assumed is that the file was deleted before (e.g. by a server job that
	 * does auto cleaning or by a client after file handling) and so just an INFO entry is logged.
	 *
	 * @param string $filePath File to delete.
	 * @return bool TRUE when the file could be deleted (or was deleted before).
	 */
	public function deleteFile( $filePath )
	{
		$deleted = true;
		if( file_exists( $filePath ) ) {
			if( !unlink( $filePath ) ) {
				LogHandler::Log( 'WEBEDIT folder clean-up', 'ERROR',
					'The file "'.$filePath.'" cannot be deleted. '.
					'Please ensure there is enough access rights to the file and folder.' );
				$deleted = false;
			}
		} else {
			// Assumed is that cleaning the same file twice is ok.
			LogHandler::Log( 'WEBEDIT folder clean-up', 'INFO',
				'Attempt to delete file "'.$filePath.'" which seems to be removed already.' );
		}
		return $deleted;
	}

	// These three functions are called by parent class, but have no meaning here.
	public function skipFile( $filePath, $level )
	{
		// Nothing to do.
	}

	public function iterFolder( $folderPath, $level )
	{
		// Nothing to do.
	}

	public function skipFolder( $folderPath, $level )
	{
		// Nothing to do.
	}
}